# 목차

- [1장. 디자인 패턴과 프로그래밍 패러다임](#1장-디자인-패턴과-프로그래밍-패러다임)
- [2장. 네트워크](#2장-네트워크)
- [3장. 운영체제](#3장-운영체제)
- [4장. 데이터베이스](#4장-데이터베이스)
- [5장. 자료 구조](#5장-자료-구조)

---

### CS 주요 질문 핵심 답변 (면접 대비용)

#### 1장. 디자인 패턴과 프로그래밍 패러다임

1.  **싱글톤 패턴의 정의, 장단점, 사용 상황은?**

    - **답변**: 싱글톤 패턴은 클래스의 인스턴스를 오직 하나만 생성하고, 어디서든 그 인스턴스에 접근할 수 있도록 하는 생성 패턴입니다.
      - **장점**: 메모리 절약, 전역적 접근 용이, 자원 공유에 유리합니다.
      - **단점**: 테스트가 어렵고, SOLID 원칙 위배 가능성이 있으며, 멀티스레드 환경에서 동기화 문제가 발생할 수 있습니다.
      - **사용 상황**: 설정 관리 객체, 커넥션 풀, 스레드 풀, 로깅 객체처럼 애플리케이션 전체에서 유일하게 관리되어야 하는 자원에 사용됩니다.
    - **꼬리 질문: 멀티스레드 환경에서 싱글톤을 안전하게 구현하는 방법은?**
      - **답변**: 네, 초기 생성(Eager Initialization), 지연 초기화와 동기화(Lazy Initialization with Synchronization), DCL(Double-Checked Locking), 그리고 가장 권장되는 방법 중 하나인 정적 내부 클래스 활용(Initialization-on-demand holder idiom) 등이 있습니다. Enum을 사용하는 것도 간결하고 안전한 방법입니다.

2.  **팩토리 패턴이란 무엇이고, 이점은?**

    - **답변**: 팩토리 패턴은 객체 생성 로직을 별도의 팩토리 클래스나 메서드로 캡슐화하여, 클라이언트가 구체적인 클래스에 직접 의존하지 않고 객체를 생성하도록 하는 패턴입니다.
      - **이점**: 클라이언트와 구체 클래스 간의 결합도를 낮추고, 새로운 클래스 추가 시 유연성과 확장성을 높입니다. 또한, 객체 생성 로직을 한 곳에서 관리하여 유지보수성을 향상시킵니다.
    - **꼬리 질문: 팩토리 메서드 패턴과 추상 팩토리 패턴의 차이점 및 적합한 상황은?**
      - **답변**: **팩토리 메서드 패턴**은 객체 생성 인터페이스를 정의하고 실제 생성은 서브클래스에 위임하여 단일 종류의 객체를 만듭니다. 반면, **추상 팩토리 패턴**은 서로 관련된 여러 객체들의 묶음, 즉 '제품군'을 생성하는 인터페이스를 제공합니다.
        - **팩토리 메서드**는 생성할 객체 타입을 예측할 수 없거나, 서브클래스에서 생성 객체를 결정하게 하고 싶을 때 적합합니다.
        - **추상 팩토리**는 여러 제품군 중 하나를 선택해 일관된 스타일의 객체들을 생성해야 할 때, 예를 들어 다양한 UI 테마에 따른 UI 요소 생성에 적합합니다.

3.  **전략 패턴에 대해 설명하고, 백엔드 적용 예시는?**

    - **답변**: 전략 패턴은 동일 계열의 알고리즘들을 개별 클래스로 캡슐화하고, 실행 중에 알고리즘을 선택하여 교체할 수 있게 하는 행위 패턴입니다. 컨텍스트 객체가 선택된 전략 객체에게 작업을 위임합니다.
      - **백엔드 예시**:
        - **다양한 결제 방식 처리**: `PaymentStrategy` 인터페이스를 두고, `CreditCardPaymentStrategy`, `BankTransferStrategy` 등을 구현하여 `PaymentService`가 상황에 맞게 전략을 선택해 결제 처리.
        - **알림 발송 방식 선택**: `NotificationStrategy` 인터페이스와 `EmailNotificationStrategy`, `SmsNotificationStrategy` 등을 구현하여 알림 종류나 사용자 설정에 따라 다른 방식으로 알림 발송.

4.  **MVC, MVP, MVVM 패턴의 의미와 주요 차이점은?**

    - **답변**: 세 패턴 모두 UI 애플리케이션의 관심사 분리를 위한 아키텍처 패턴입니다.

      - **MVC (Model-View-Controller)**: 모델(데이터/로직), 뷰(UI), 컨트롤러(입력 처리/중재)로 구성됩니다. 뷰와 모델이 직접 상호작용 가능하며, 컨트롤러가 뷰를 선택할 수 있습니다.
      - **MVP (Model-View-Presenter)**: 모델, 뷰, 프레젠터(뷰-모델 중재, 뷰 로직 처리)로 구성됩니다. 뷰와 모델은 프레젠터를 통해서만 상호작용하며, 뷰는 수동적 역할을 합니다. 프레젠터와 뷰는 보통 1:1 관계입니다.
      - **MVVM (Model-View-ViewModel)**: 모델, 뷰, 뷰모델(뷰를 위한 데이터/상태/로직)로 구성됩니다. 데이터 바인딩과 커맨드 패턴이 핵심이며, 뷰모델은 뷰를 직접 알지 못해 테스트 용이성이 매우 높습니다.
      - **주요 차이점**: 모델-뷰 간 상호작용 방식(MVC는 직접 가능, MVP/MVVM은 중재자 통함), 뷰의 로직 처리 주체(MVC는 컨트롤러, MVP는 프레젠터, MVVM은 뷰모델), 그리고 뷰와 로직 처리 주체 간의 결합도 및 테스트 용이성에서 차이가 있습니다.

    - **꼬리 질문: 백엔드 API 서버 설계 시 참고할 만한 요소나 주로 논의되는 아키텍처 패턴은?**
      - **답변**: 백엔드에서는 MVC의 컨트롤러(요청 라우팅), 모델(서비스/데이터 로직) 개념을 차용합니다. 주로 논의되는 패턴은 **계층형 아키텍처**(표현-비즈니스-데이터 접근 계층 분리), **헥사고날 아키텍처**(도메인 중심, 외부 의존성 분리), 그리고 대규모 시스템에서는 **마이크로서비스 아키텍처** 등이 있습니다.

5.  **객체지향 프로그래밍(OOP)의 4가지 주요 특징과 각 이점은?**
    - **답변**: OOP의 4가지 주요 특징은 추상화, 캡슐화, 상속, 다형성입니다.
      - **추상화**: 불필요한 세부 사항은 숨기고 핵심적인 부분만 드러내 복잡성을 줄이고 모델링을 용이하게 합니다.
      - **캡슐화**: 데이터와 관련 메서드를 묶고 정보 은닉을 통해 데이터 보호, 유지보수성 및 응집도를 향상시킵니다.
      - **상속**: 기존 클래스의 속성과 메서드를 물려받아 코드 재사용성을 높이고 계층적 관계를 표현합니다.
      - **다형성**: 하나의 인터페이스나 부모 타입으로 여러 다른 자식 객체를 다룰 수 있게 하여 유연성, 확장성, 코드 간결성을 높입니다.
    - **꼬리 질문: 함수형 프로그래밍(FP)과 비교했을 때 OOP의 장단점은?**
      - **답변**:
        - **OOP 장점**: 현실 세계를 직관적으로 모델링하기 좋고, 캡슐화를 통해 상태 관리가 명확할 수 있습니다. 기존 시스템과의 통합이나 잘 정립된 디자인 패턴 활용도 용이합니다.
        - **OOP 단점**: 가변 상태로 인해 동시성 문제나 예측 어려움이 있을 수 있고, 부수 효과로 테스트가 어려워질 수 있습니다. 상속의 오용은 유연성을 저해할 수 있습니다.
        - **FP 장점**: 불변성과 순수 함수를 지향하여 예측 가능성이 높고 테스트가 용이하며, 동시성 프로그래밍에 유리합니다. 코드가 간결하고 선언적일 수 있습니다.
        - **FP 단점**: 학습 곡선이 있고, 상태 변경이 많은 로직이나 I/O 처리가 다소 복잡할 수 있으며, 불변성 유지를 위한 성능 오버헤드가 있을 수 있습니다.

---

#### 2장. 네트워크

1.  **TCP와 UDP 프로토콜의 주요 차이점과 각각 적합한 서비스는?**

    - **답변**: TCP와 UDP는 전송 계층 프로토콜입니다.
      - **TCP**: 연결형 프로토콜로, 3-way handshake로 연결을 수립하고 데이터 전송의 신뢰성(재전송, 순서 보장)과 흐름/혼잡 제어를 지원합니다. 따라서 웹 브라우징(HTTP/HTTPS), 파일 전송(FTP), 이메일(SMTP)처럼 데이터의 정확한 전달이 중요한 서비스에 적합합니다.
      - **UDP**: 비연결형 프로토콜로, 신뢰성이나 순서를 보장하지 않지만 헤더가 작고 전송 속도가 빠릅니다. 따라서 실시간 스트리밍(온라인 게임, 영상/음성 통화), DNS처럼 약간의 데이터 손실을 감수하더라도 빠른 전송이 중요한 서비스에 적합합니다.
    - **꼬리 질문: TCP의 3-way/4-way handshake와 TIME_WAIT 상태의 필요성은?**
      - **답변**:
        - **3-way handshake**: 클라이언트가 SYN, 서버가 SYN+ACK, 클라이언트가 ACK를 보내 연결을 수립하는 과정으로, 양측의 통신 준비 상태와 초기 시퀀스 번호를 교환합니다.
        - **4-way handshake**: 연결 종료 시, 각 방향으로 FIN과 ACK를 교환하여 안전하게 연결을 해제합니다. (클라이언트 FIN -> 서버 ACK -> 서버 FIN -> 클라이언트 ACK)
        - **TIME_WAIT 상태**: 주로 먼저 연결 종료를 요청한 측에서 발생하며, 첫째로 네트워크에 남아있을 수 있는 이전 연결의 지연된 패킷으로 인한 충돌을 방지하고, 둘째로 상대방의 마지막 FIN에 대한 ACK가 유실되었을 경우 이를 재전송하여 상대방이 정상적으로 연결을 종료하도록 보장하기 위해 필요합니다.

2.  **HTTP/1.1, HTTP/2, HTTP/3의 주요 특징과 발전 과정, 특히 HTTP/2의 핵심 기능과 HTTP/3가 QUIC을 사용하는 이유는?**

    - **답변**:

      - **HTTP/1.1**: 지속적 연결(Keep-Alive), 파이프라이닝(널리 사용 X)을 도입했지만, HOL(Head-of-Line) Blocking 문제와 비효율적인 헤더 문제가 있었습니다.
      - **HTTP/2**: SPDY 기반으로, **멀티플렉싱**(하나의 TCP 연결에서 여러 요청/응답 동시 처리, HOL Blocking 해결), **헤더 압축**(HPACK), **서버 푸시**(클라이언트 요청 전 리소스 전송) 등의 기능으로 성능을 크게 향상시켰습니다. 이진 프로토콜을 사용합니다.
      - **HTTP/3**: UDP 기반의 **QUIC 프로토콜**을 사용합니다.
        - **QUIC 사용 이유**: TCP 자체의 HOL Blocking 문제(패킷 손실 시 전체 스트림 지연)를 해결하고, 연결 설정 시간 단축(0-RTT 또는 1-RTT), 연결 마이그레이션(IP 변경 시 연결 유지) 등을 통해 모바일 환경 등에서 더 빠르고 안정적인 통신을 제공하기 위함입니다.

    - **꼬리 질문: HTTP/1.1의 Keep-Alive와 파이프라이닝의 문제점과 한계는?**
      - **답변**:
        - **Keep-Alive**: 매번 TCP 연결을 새로 맺는 오버헤드를 줄였지만, 하나의 연결에서 한 번에 하나의 요청만 순차적으로 처리하여 HOL Blocking 문제는 여전했습니다.
        - **파이프라이닝**: 응답을 기다리지 않고 여러 요청을 보낼 수 있게 했으나, 서버는 요청 순서대로 응답해야 하는 제약과 구현의 어려움, 프록시 호환성 문제 등으로 널리 사용되지 못했고 HOL Blocking 문제도 해결하지 못했습니다.

3.  **HTTPS의 작동 원리, SSL/TLS 핸드셰이크 시 대칭키/비대칭키 사용 방식, CA의 역할은?**

    - **답변**: HTTPS는 HTTP 통신을 SSL/TLS 프로토콜로 암호화하여 데이터의 기밀성, 무결성, 서버 인증을 보장합니다.

      - **SSL/TLS 핸드셰이크 과정**:
        1.  클라이언트가 지원 가능한 암호화 방식(Cipher Suites) 등을 서버에 알립니다 (Client Hello).
        2.  서버는 선택된 암호화 방식과 자신의 공개키가 담긴 인증서를 클라이언트에 전달합니다 (Server Hello, Certificate).
        3.  클라이언트는 CA(인증 기관)를 통해 서버 인증서를 검증합니다.
        4.  클라이언트는 Pre-Master Secret(임시 비밀키)을 생성하여 서버의 공개키로 암호화해 전송합니다 (**비대칭키 암호화** 사용).
        5.  서버는 자신의 개인키로 이를 복호화하고, 양측은 이 Pre-Master Secret을 기반으로 실제 데이터 암호화에 사용할 **대칭키(세션키)**를 생성합니다.
        6.  이후 모든 통신은 이 대칭키를 사용하여 암호화됩니다.
      - **대칭키/비대칭키 사용**: 비대칭키는 연산 속도가 느려 실제 데이터 암호화에는 부적합하므로, 안전하게 대칭키(세션키)를 교환하는 데 사용됩니다. 실제 데이터 암호화는 속도가 빠른 대칭키를 사용합니다.
      - **CA (Certificate Authority) 역할**: 신뢰할 수 있는 제3자 기관으로, 웹사이트 운영자의 신원을 확인하고 서버의 공개키가 포함된 디지털 인증서를 발급하며, 이 인증서의 진위성을 보증합니다. 브라우저는 내장된 루트 CA 목록을 통해 서버 인증서의 신뢰성을 검증합니다.

    - **꼬리 질문: SSL 인증서 포함 정보와 브라우저의 검증 과정은?**
      - **답변**:
        - **SSL 인증서 포함 정보**: 주체(도메인 이름, 조직 정보), 발급자(CA 정보), 유효 기간, 공개키, CA의 디지털 서명 등이 포함됩니다.
        - **브라우저 검증 과정**:
          1.  CA의 디지털 서명을 해당 CA의 공개키로 복호화하여 인증서의 위변조 여부를 확인합니다.
          2.  인증서의 유효 기간과 현재 접속한 도메인 이름이 인증서의 정보와 일치하는지 확인합니다.
          3.  인증서가 폐기되었는지 CRL 또는 OCSP를 통해 확인합니다.
          4.  루트 CA까지의 신뢰 체인을 검증합니다.

4.  **RESTful API란 무엇이고, REST 아키텍처 스타일의 주요 제약 조건은?**

    - **답변**: REST(Representational State Transfer)는 웹과 같은 분산 시스템을 위한 아키텍처 스타일이며, RESTful API는 이 스타일을 잘 따른 API입니다. 자원(Resource)을 URI로 표현하고, 자원에 대한 행위(Verb)를 HTTP 메서드로 정의하며, 자원의 상태를 표현(Representation, 예: JSON, XML)으로 주고받습니다.

      - **주요 제약 조건**:
        1.  **클라이언트-서버 구조**: 역할 분리.
        2.  **무상태성 (Statelessness)**: 서버는 클라이언트 상태를 저장하지 않음. 각 요청은 독립적.
        3.  **캐시 가능성 (Cacheability)**: 클라이언트는 응답을 캐시할 수 있어야 함.
        4.  **계층화된 시스템 (Layered System)**: 클라이언트는 최종 서버만 알면 됨. 중간 계층 존재 가능.
        5.  **균일한 인터페이스 (Uniform Interface)**: 자원 식별(URI), 표현을 통한 자원 조작, 자기 서술적 메시지, HATEOAS(애플리케이션 상태 엔진으로서 하이퍼미디어).
        6.  (선택적) **코드 온 디맨드**: 서버가 클라이언트에 실행 가능한 코드를 전송.

    - **꼬리 질문: 좋은 REST API 설계 원칙/고려 사항은?**
      - **답변**:
        - **자원 중심 URI 설계**: 명사 사용, 계층 구조, 일관된 명명(복수형, 소문자), 파일 확장자 미포함.
        - **적절한 HTTP 메서드 활용**: GET(조회), POST(생성), PUT(전체 수정), PATCH(부분 수정), DELETE(삭제) 등 의미에 맞게 사용.
        - **명확한 HTTP 상태 코드 사용**: 2xx(성공), 4xx(클라이언트 오류), 5xx(서버 오류) 등 정확히 사용하고, 오류 시 상세 메시지 제공.
        - **일관된 응답 데이터 형식**: 주로 JSON 사용, 페이징/필터링 정보 포함, HATEOAS 적용 고려.
        - **API 버전 관리**: 하위 호환성 고려 (URI 경로 또는 헤더 사용).
        - **보안**: HTTPS 사용, 인증/인가, 입력값 검증.
        - **문서화**: Swagger/OpenAPI 등 활용.

5.  **사용자가 www.example.com 입력 시 웹 페이지 표시까지의 네트워크 통신 과정은? (DNS 조회부터, 로드밸런서/CDN 언급 가능)**

    - **답변**:

      1.  **URL 파싱**: 브라우저가 URL(`www.example.com`)을 파싱합니다.
      2.  **(HSTS 확인)**: HTTPS 강제 여부 확인.
      3.  **DNS 조회**:
          - 브라우저/OS 캐시 확인 -> 로컬 DNS 서버에 `www.example.com`의 IP 주소 질의.
          - 로컬 DNS 서버는 루트 -> TLD -> 권한 있는 DNS 서버 순으로 반복적 질의를 통해 IP 주소를 획득. (CDN 사용 시 가까운 엣지 서버 IP 반환 가능)
      4.  **TCP 연결 수립**: 획득한 IP와 포트(HTTP 80, HTTPS 443)로 서버와 3-way handshake.
      5.  **(TLS 핸드셰이크)**: HTTPS인 경우, 암호화 통신 채널 수립.
      6.  **HTTP 요청**: 브라우저가 서버로 HTTP 요청 메시지(메서드, 헤더, 본문 등) 전송.
      7.  **서버 처리**:
          - **(로드 밸런서)**: 요청을 적절한 백엔드 서버로 분산.
          - 웹 서버(Nginx, Apache)가 요청 수신 후 WAS(Tomcat, Node.js)에 처리 위임. WAS는 비즈니스 로직 수행, DB 연동.
      8.  **HTTP 응답**: 서버가 HTTP 응답 메시지(상태 코드, 헤더, 본문 - HTML 등) 전송.
          - **(CDN)**: 정적 콘텐츠는 가까운 CDN 엣지 서버에서 응답 가능.
      9.  **브라우저 렌더링**:
          - HTML 파싱(DOM 트리) -> CSS 파싱(CSSOM 트리) -> 렌더 트리 구축 -> 레이아웃 -> 페인팅.
          - 추가 리소스(JS, 이미지 등) 요청 및 처리.
      10. **(TCP 연결 해제)**: 통신 완료 후 연결 종료.

    - **꼬리 질문: DNS 서버는 도메인 이름에 대한 IP 주소를 어떻게 찾아가나? (Recursive/Iterative Query)**
      - **답변**:
        - **Recursive Query (재귀적 질의)**: 주로 PC(클라이언트)가 로컬 DNS 서버에게 요청하는 방식입니다. 로컬 DNS 서버는 IP 주소를 찾아서 최종 답변을 줄 책임이 있습니다.
        - **Iterative Query (반복적 질의)**: 로컬 DNS 서버가 다른 DNS 서버들에게 질의하는 방식입니다. 각 DNS 서버는 자신이 아는 최선의 정보(다음 질의할 서버 주소 또는 최종 IP)를 응답하고, 로컬 DNS 서버는 이 정보를 바탕으로 다음 서버에 반복적으로 질의합니다. (루트 DNS -> TLD DNS -> 권한 있는 DNS 순)

---

#### 3장. 운영체제

1.  **프로세스와 스레드의 차이점, 멀티스레딩의 정의/장단점/주의사항, 스레드가 스택만 독립적으로 가지는 이유는?**

    - **답변**:

      - **프로세스**: 실행 중인 프로그램, 독립된 메모리 공간(코드, 데이터, 힙, 스택) 할당.
      - **스레드**: 프로세스 내 실행 흐름 단위, 프로세스의 코드/데이터/힙 공유, 독립된 스택/PC/레지스터 가짐.
      - **차이점**: 자원 공유 여부(프로세스는 독립, 스레드는 공유), 생성/관리 비용(스레드가 훨씬 저렴), 통신 방식(스레드 간 통신이 더 간단하고 빠름).
      - **멀티스레딩**: 하나의 프로세스가 여러 스레드로 여러 작업 병행 처리.
        - **장점**: 자원 효율성(메모리 공유, 컨텍스트 스위칭 비용 적음), 응답성 향상, 통신 용이.
        - **단점/주의사항**: 동기화 문제(경쟁 상태, 데드락), 디버깅 어려움, 하나의 스레드 오류가 전체 프로세스에 영향.
      - **스택만 독립적인 이유**: 각 스레드는 독립적인 함수 호출 흐름을 가지므로, 함수 호출 시 매개변수, 지역 변수, 복귀 주소 등을 저장하는 스택은 각 스레드별로 독립적으로 관리되어야 정상적인 실행이 가능합니다. 반면 코드, 데이터, 힙은 공유를 통해 효율성과 통신을 용이하게 합니다.

    - **꼬리 질문: 컨텍스트 스위칭이란? 프로세스 간/스레드 간 차이점? 발생 시점은?**
      - **답변**:
        - **컨텍스트 스위칭**: 현재 CPU 사용 중인 프로세스/스레드의 실행을 중단하고, 다른 프로세스/스레드에게 CPU 제어권을 넘겨주는 과정. 현재 상태(컨텍스트)는 PCB/TCB에 저장, 새 컨텍스트는 로드.
        - **프로세스 간 vs 스레드 간 차이**:
          - **프로세스 간**: 독립 메모리 공간, CPU 레지스터 외 메모리 관리 정보(페이지 테이블 등) 교체, TLB flush 등 오버헤드 큼.
          - **스레드 간 (같은 프로세스 내)**: 코드/데이터/힙 공유, 스택/레지스터 등 일부만 교체, 오버헤드 작음.
        - **발생 시점**: 인터럽트(I/O 완료, 타이머 만료), 시스템 호출, 프로세스/스레드의 자발적 CPU 양보(자원 대기 등), 스케줄러의 결정(우선순위 높은 작업 등장 등).

2.  **메모리 관리에서 페이징과 세그멘테이션 기법 설명, 장단점, 내부/외부 단편화 연관 설명은?**

    - **답변**:

      - **페이징**: 프로세스를 고정 크기의 **페이지**로, 물리 메모리를 **프레임**으로 나누어 관리. **페이지 테이블**로 매핑.
        - **장점**: 외부 단편화 해결, 메모리 관리 용이.
        - **단점**: 내부 단편화 발생 가능(마지막 페이지), 페이지 테이블 오버헤드.
      - **세그멘테이션**: 프로세스를 논리적 의미 단위(코드, 데이터, 스택 등)의 가변 크기 **세그먼트**로 나누어 관리. **세그먼트 테이블**로 매핑.
        - **장점**: 논리적 단위 관리(공유/보호 용이), 내부 단편화 없음.
        - **단점**: 외부 단편화 발생, 메모리 관리 복잡.
      - **단편화**:
        - **내부 단편화**: 할당 공간 > 필요 공간 (페이징에서 발생).
        - **외부 단편화**: 가용 공간은 충분하나 연속적이지 않아 할당 불가 (세그멘테이션에서 발생).

    - **꼬리 질문: 가상 메모리 필요성, 요구 페이징, 페이지 폴트란?**
      - **답변**:
        - **가상 메모리 필요성**: 물리 메모리 크기 제약 극복, 메모리 관리 효율 증대, 프로세스 보호, 프로그래밍 편의성.
        - **요구 페이징**: 프로세스 실행 시 실제로 필요한 페이지만 물리 메모리에 적재하는 방식. 초기 로딩 시간 단축, 메모리 사용량 감소.
        - **페이지 폴트**: 접근하려는 페이지가 물리 메모리에 없는 경우 발생하는 인터럽트. 운영체제가 디스크에서 해당 페이지를 메모리로 가져오고(필요시 페이지 교체), 페이지 테이블 업데이트 후 명령 재시작.

3.  **교착 상태(Deadlock) 정의와 발생 조건 4가지는?**

    - **답변**: 교착 상태는 둘 이상의 프로세스가 각자 점유한 자원을 놓지 않으면서, 서로 상대방이 점유한 자원을 무한정 기다려 진행이 멈추는 상태입니다.

      - **발생 조건 (모두 충족 시)**:
        1.  **상호 배제**: 한 번에 하나의 프로세스만 자원 사용.
        2.  **점유와 대기**: 자원을 가진 프로세스가 다른 자원을 기다리며 보유 자원 유지.
        3.  **비선점**: 할당된 자원을 강제로 빼앗을 수 없음.
        4.  **환형 대기**: 프로세스들이 원형으로 서로의 자원을 기다림.

    - **꼬리 질문: 교착 상태 해결 방법(예방, 회피, 탐지/회복) 특징? 은행원 알고리즘은 어디에 속하나?**
      - **답변**:
        - **예방**: 발생 조건 중 하나를 원천 제거. 자원 효율성 저하 가능.
        - **회피**: 자원 할당 시 안전 상태(교착 없는 상태) 유지 여부 검사 후 할당. **은행원 알고리즘**이 대표적. 자원 필요량 사전 선언 및 오버헤드 발생.
        - **탐지 및 회복**: 교착 발생 허용 후 탐지, 발생 시 프로세스 종료 또는 자원 선점으로 회복. 탐지/회복 비용 발생.
        - **무시**: 발생 빈도가 낮다고 가정하고 처리 안 함. 대부분 OS 채택.

4.  **CPU 스케줄링 알고리즘 중 선점형/비선점형 차이? 대표 알고리즘(FCFS, SJF, Priority, Round Robin) 특징/장단점은?**

    - **답변**:

      - **비선점형**: 한 프로세스가 CPU 할당 시 스스로 반납 전까지 다른 프로세스가 빼앗을 수 없음. (예: FCFS, 비선점형 SJF/Priority)
      - **선점형**: 실행 중인 프로세스로부터 OS가 CPU를 강제로 빼앗아 다른 프로세스에 할당 가능. (예: Round Robin, SRTF, 선점형 Priority)
      - **대표 알고리즘**:
        - **FCFS (비선점)**: 도착 순 처리. 간단, 호위 효과로 평균 대기 시간 김.
        - **SJF (비선점/선점-SRTF)**: 실행 시간 가장 짧은 작업 우선. 평균 대기 시간 최소화, 실행 시간 예측 어렵고 기아 현상 가능.
        - **Priority (비선점/선점)**: 우선순위 높은 작업 우선. 중요 작업 먼저 처리, 기아 현상 가능(에이징으로 완화).
        - **Round Robin (선점)**: 동일 시간 할당량(타임 퀀텀)씩 CPU 사용 후 준비 큐 맨 뒤로. 공평, 응답 시간 빠름, 타임 퀀텀 크기 중요.

    - **꼬리 질문: Round Robin에서 타임 퀀텀 크기 문제? 기아 현상이란? 발생 쉬운 알고리즘은?**
      - **답변**:
        - **타임 퀀텀 크기 문제**: 너무 크면 FCFS처럼 응답 시간 길어짐. 너무 작으면 잦은 문맥 교환으로 오버헤드 커짐.
        - **기아 현상**: 특정 프로세스가 자원 할당 우선순위에서 계속 밀려 실행되지 못하는 상태.
        - **발생 쉬운 알고리즘**: SJF/SRTF(긴 작업), Priority(낮은 우선순위 작업).

5.  **공유 자원 접근 시 경쟁 상태(Race Condition)란? 해결 위한 동기화 기법(뮤텍스, 세마포어)은?**

    - **답변**:

      - **경쟁 상태**: 둘 이상의 프로세스/스레드가 공유 자원에 동시 접근 시, 접근 순서에 따라 결과가 달라지는 상황. 데이터 무결성 저해.
      - **해결 위한 동기화 기법**: 임계 영역(공유 자원 접근 코드)에 상호 배제(한 번에 하나만 진입) 보장.
        - **뮤텍스 (Mutex)**: 하나의 스레드만 획득(lock) 가능한 동기화 객체. 임계 영역 접근 제어. 잠근 스레드만 해제(unlock) 가능 (소유권).
        - **세마포어 (Semaphore)**: 지정된 개수만큼 스레드/프로세스 동시 접근 허용하는 카운터.
          - **이진 세마포어**: 값 0/1. 뮤텍스와 유사하게 상호 배제 또는 실행 순서 제어(신호).
          - **카운팅 세마포어**: 값 0 이상. 여러 동일 자원 동시 접근 제어 (예: 커넥션 풀).

    - **꼬리 질문: 뮤텍스와 세마포어 차이점? 각각 적절한 사용 상황은?**
      - **답변**:
        - **차이점**: 뮤텍스는 암묵적으로 자원 1개 관리(잠금/해제), 소유권 개념 있음. 세마포어는 카운터로 0개 이상 자원 관리, 소유권 개념 없음.
        - **사용 상황**:
          - **뮤텍스**: 단일 공유 자원 또는 임계 영역의 단순 상호 배제 필요 시.
          - **세마포어**: 여러 자원 접근 제어, 복잡한 동기화 패턴(실행 순서 제어, 생산자-소비자) 구현 시. (이진 세마포어는 신호용, 카운팅 세마포어는 자원 개수 관리용)

---

#### 4장. 데이터베이스

1.  **RDBMS와 NoSQL DB의 근본적 차이점? 각각 적합한 애플리케이션/데이터 모델 예시는?**

    - **답변**:

      - **RDBMS**: 정해진 스키마(테이블), 관계 통해 데이터 표현, ACID 트랜잭션(강력한 일관성), 주로 수직적 확장, SQL 사용.
        - **적합**: 데이터 무결성/일관성 중요(금융), 정형 데이터, 복잡한 관계 분석(ERP). (예: MySQL, PostgreSQL)
      - **NoSQL**: 유연한 스키마, 다양한 데이터 모델(Key-Value, Document 등), BASE 모델(최종적 일관성) 지향하는 경우 많음, 주로 수평적 확장, 각 모델별 쿼리 방식.
        - **적합**: 대용량/빠른 읽기쓰기(소셜 피드), 비정형 데이터(로그), 높은 가용성/확장성(온라인 서비스). (예: Redis, MongoDB, Cassandra, Neo4j)

    - **꼬리 질문: NoSQL 종류별 특징/사용 사례? CAP 이론 설명?**
      - **답변**:
        - **NoSQL 종류**:
          - **Key-Value**: 단순 키-값. Redis(캐싱, 세션).
          - **Document**: JSON/BSON 문서. MongoDB(콘텐츠 관리, 프로필).
          - **Column-Family**: 컬럼 패밀리 단위. Cassandra(빅데이터, 시계열).
          - **Graph**: 노드와 관계로 표현. Neo4j(소셜 분석, 추천).
        - **CAP 이론**: 분산 시스템은 일관성(C), 가용성(A), 분할 허용성(P) 중 최대 2가지만 만족 가능. P는 필수이므로 C와 A 중 선택.
          - **CP**: 일관성 우선, 가용성 저하 가능.
          - **AP**: 가용성 우선, 일관성 저하 가능(최종적 일관성).

2.  **DB 정규화 목적? 1NF, 2NF, 3NF 설명?**

    - **답변**:

      - **정규화 목적**: 데이터 중복 최소화, 데이터 무결성 향상, 이상 현상(삽입/갱신/삭제) 방지, 테이블 구조 안정성/확장성 확보.
      - **1NF**: 모든 컬럼 값이 원자 값 (더 이상 분해 불가, 반복 그룹 없음).
      - **2NF**: 1NF 만족 + 기본 키 아닌 모든 컬럼이 기본 키 전체에 완전 함수적 종속 (부분 함수적 종속 없음 - 복합 키일 때 문제).
      - **3NF**: 2NF 만족 + 기본 키 아닌 모든 컬럼이 기본 키에 이행적 함수적 종속 없음 (기본 키 아닌 컬럼이 다른 일반 컬럼에 의해 결정되지 않음).

    - **꼬리 질문: 정규화 장단점(성능 저하 가능성)? 반정규화 수행 이유는?**
      - **답변**:
        - **정규화 장점**: 데이터 중복 최소화, 무결성 강화, 이상 현상 방지, 유지보수/확장 용이.
        - **정규화 단점**: 테이블 분리로 JOIN 연산 증가, 쿼리 복잡도 증가로 조회 성능 저하 가능성.
        - **반정규화 이유**: 정규화된 테이블에서 조회 성능 향상을 위해 의도적으로 데이터 중복 허용 또는 테이블 통합. JOIN 연산 줄여 응답 속도 개선 목적. (읽기 작업 빈번, 빠른 응답 중요 시스템에 고려)

3.  **트랜잭션 ACID 속성 설명? DB 시스템에서 왜 중요한가?**

    - **답변**: 트랜잭션은 하나의 논리적 작업 단위입니다. ACID는 트랜잭션의 안전한 수행을 위한 4가지 속성입니다.

      - **원자성(Atomicity)**: 모든 연산이 전부 성공 또는 전부 실패 (All or Nothing). 부분 성공/실패 방지.
      - **일관성(Consistency)**: 트랜잭션 후에도 DB는 일관된 상태 유지 (제약 조건 만족). 데이터 유효성/정확성 보장.
      - **고립성(Isolation)**: 여러 트랜잭션 동시 실행 시 서로 영향 없이 독립적 실행처럼 보여야 함. 동시성 문제 방지.
      - **지속성(Durability)**: 성공한 트랜잭션 결과는 시스템 장애에도 영구 저장. 데이터 영속성 보장.
      - **중요성**: ACID는 DB가 신뢰할 수 있는 데이터 저장소 역할을 하기 위한 기본 요구사항으로, 데이터 무결성, 일관성, 안정성을 보장합니다.

    - **꼬리 질문: 트랜잭션 격리 수준 종류? 각 수준별 발생 문제점(Dirty Read, Non-Repeatable Read, Phantom Read)?**
      - **답변**:
        - **문제점**:
          - **Dirty Read**: 커밋되지 않은 다른 트랜잭션의 수정 내용 읽음.
          - **Non-Repeatable Read**: 한 트랜잭션 내 동일 쿼리 반복 시 다른 트랜잭션의 수정/커밋으로 결과 달라짐.
          - **Phantom Read**: 한 트랜잭션 내 동일 범위 쿼리 반복 시 다른 트랜잭션의 삽입/삭제/커밋으로 없던 행이 생기거나 있던 행이 사라짐.
        - **격리 수준**:
          1.  **Read Uncommitted (레벨 0)**: 모든 문제 발생 가능.
          2.  **Read Committed (레벨 1)**: Dirty Read 방지. Non-Repeatable, Phantom Read 발생 가능. (대부분 DB 기본)
          3.  **Repeatable Read (레벨 2)**: Dirty Read, Non-Repeatable Read 방지. Phantom Read 발생 가능. (MySQL InnoDB 기본)
          4.  **Serializable (레벨 3)**: 모든 문제 방지. 가장 강력한 일관성, 동시성 가장 낮음.

4.  **DB 인덱스 역할/필요성? 장단점(오버헤드)?**

    - **답변**:

      - **역할/필요성**: 테이블에서 특정 데이터를 빠르게 찾도록 돕는 데이터 구조. `SELECT` 쿼리의 `WHERE` 절, `JOIN` 조건 검색 속도 향상. 시스템 부하 감소.
      - **장점**: 빠른 데이터 검색, 쿼리 성능 최적화, 시스템 전반 성능 향상.
      - **단점(오버헤드)**: 추가 저장 공간 차지. DML(INSERT, UPDATE, DELETE) 성능 저하 (인덱스 유지보수 비용). 인덱스 관리 어려움.

    - **꼬리 질문: B-Tree 인덱스와 해시 인덱스 차이점? 각각 유리한 상황? 복합 인덱스 컬럼 순서 중요 이유는?**
      - **답변**:
        - **B-Tree vs 해시 인덱스**:
          - **B-Tree**: 균형 트리 구조, 정렬. 등호(=), 범위(>,<), 부분 일치(LIKE 'abc%') 검색 효율적. 대부분 RDBMS 기본.
          - **해시**: 해시 테이블 구조, 비정렬. 등호(=) 검색 매우 빠름(평균 O(1)), 범위 검색 비효율적. 주로 메모리 DB, 특정 조건에 사용.
        - **복합 인덱스 컬럼 순서 중요 이유**: B-Tree 인덱스는 왼쪽에서 오른쪽으로 정렬. 쿼리 조건에 인덱스 첫 번째 컬럼이 사용되어야 효율적. 카디널리티 높고 선택도 좋은 컬럼을 앞 순서에 두는 것이 유리. `ORDER BY`, `GROUP BY` 절도 순서 일치 시 성능 향상.

5.  **SQL JOIN 종류(INNER, LEFT/RIGHT/FULL OUTER) 설명? 언제 사용, 결과셋 차이 예시?**

    - **답변**: JOIN은 두 개 이상 테이블에서 관련 데이터를 결합합니다.

      - **INNER JOIN**: 양쪽 테이블 모두 JOIN 조건 만족하는 행만 결합. (공통 데이터만)
      - **LEFT OUTER JOIN**: 왼쪽 테이블 모든 행 포함, 오른쪽은 조건 만족 시 결합, 불일치 시 NULL. (왼쪽 기준 + 오른쪽 정보)
      - **RIGHT OUTER JOIN**: 오른쪽 테이블 모든 행 포함, 왼쪽은 조건 만족 시 결합, 불일치 시 NULL. (오른쪽 기준 + 왼쪽 정보)
      - **FULL OUTER JOIN**: 양쪽 테이블 모든 행 포함, 조건 만족 시 결합, 불일치 시 NULL. (양쪽 모든 데이터)
      - **예시**: `Employees(EmpID, EmpName, DeptID)`와 `Departments(DeptID, DeptName)` 테이블.
        - INNER JOIN: 부서 배정된 직원과 해당 부서명.
        - LEFT JOIN: 모든 직원 정보 + (있다면) 부서명. (부서 미배정 직원은 부서명 NULL)
        - RIGHT JOIN: 모든 부서 정보 + (있다면) 직원명. (직원 없는 부서는 직원명 NULL)
        - FULL JOIN: 모든 직원과 모든 부서 정보. (짝 없으면 해당 정보 NULL)

    - **꼬리 질문: JOIN 연산 성능 최적화 고려 사항?**
      - **답변**: JOIN 조건 컬럼에 **인덱스 생성** (가장 중요). JOIN 조건 컬럼 데이터 타입 일치. 옵티마이저 위한 **DB 통계 정보 최신 유지**. 필요한 컬럼만 `SELECT`. `WHERE` 절로 데이터 필터링 후 JOIN. 적절한 JOIN 유형 선택. **실행 계획 분석**으로 병목 확인.

---

#### 5장. 자료 구조

1.  **배열과 연결 리스트 내부 구조/특징 비교, 장단점, 연산별 시간 복잡도는?**

    - **답변**:
      - **배열**: 동일 타입 데이터, 연속된 메모리, 인덱스로 직접 접근(Random Access).
        - **장점**: 빠른 접근(O(1)).
        - **단점**: 크기 고정, 삽입/삭제 비효율(O(N)).
        - **시간 복잡도**: 검색(인덱스) O(1), 삽입/삭제 O(N).
      - **연결 리스트**: 노드(데이터+포인터)로 구성, 메모리 흩어짐, 순차 접근(Sequential Access).
        - **장점**: 유연한 크기, 효율적 삽입/삭제(O(1) - 위치 알 때).
        - **단점**: 느린 접근(O(N)), 추가 포인터 공간 필요.
        - **시간 복잡도**: 검색 O(N), 삽입/삭제(맨 앞 O(1), 중간/끝 O(N) 또는 O(1) - 구현 따라).
      - **유리한 상황**: 배열(크기 고정, 빠른 접근 중요), 연결 리스트(크기 유동적, 삽입/삭제 빈번).

2.  **해시 테이블 작동 원리(해시 함수, 버킷, 충돌 해결)? 주요 충돌 해결 전략(Chaining, Open Addressing)?**

    - **답변**:

      - **작동 원리**: 키(Key)를 해시 함수로 해시 값(인덱스) 변환, 해당 인덱스의 버킷(배열 칸)에 값(Value) 저장/검색. 평균 O(1) 성능.
      - **해시 충돌**: 다른 키가 같은 해시 값 갖는 현상.
      - **충돌 해결 전략**:
        - **체이닝 (Separate Chaining)**: 각 버킷을 연결 리스트나 트리로 만들어 충돌 데이터를 연결. Java `HashMap`에서 사용 (길이 길어지면 트리로 변환).
        - **개방 주소법 (Open Addressing)**: 충돌 시 다른 빈 버킷 찾아 저장. (선형 탐사, 제곱 탐사, 이중 해싱 등)

    - **꼬리 질문: 좋은 해시 함수 조건? Java `HashMap` 내부 동작?**
      - **답변**:
        - **좋은 해시 함수 조건**: 결정론적, 빠른 계산, 균등 분포(충돌 최소화), 키 변화에 민감(눈사태 효과).
        - **Java `HashMap` 내부 동작**: `Node[] table` 배열 사용. `key.hashCode()`와 내부 해시 함수로 인덱스 결정. 충돌 시 기본 체이닝, 연결 리스트 길이 8 이상 시 레드-블랙 트리로 변환. 로드 팩터(기본 0.75) 초과 시 2배 리사이징 및 재해싱. (스레드 안전 X)
    - **꼬리 질문: 해시 테이블 검색 시간 복잡도가 어떻게 O(1)을 유지하나?**
      - **답변**: 해시 함수로 키를 배열 인덱스로 직접 매핑하기 때문입니다. 해시 함수 연산(O(1)) + 배열 인덱스 접근(O(1)) = O(1)입니다. 충돌이 발생할 수 있지만, 좋은 해시 함수, 적절한 로드 팩터 관리, 효율적인 충돌 해결 전략을 통해 충돌로 인한 추가 작업이 평균적으로 매우 적게 발생하여, 평균 O(1)을 유지합니다.

3.  **스택과 큐 자료 구조 특징(LIFO, FIFO), 차이점, 대표 활용 예시는?**

    - **답변**:

      - **스택 (Stack)**: LIFO (Last-In, First-Out, 후입선출). 한쪽 끝(top)에서 삽입(push)/삭제(pop).
        - **활용 예시**: 함수 호출 스택, 수식 계산, 괄호 검사, 웹 브라우저 뒤로 가기, DFS.
      - **큐 (Queue)**: FIFO (First-In, First-Out, 선입선출). 한쪽 끝(rear)에서 삽입(enqueue), 다른 쪽 끝(front)에서 삭제(dequeue).
        - **활용 예시**: BFS, OS 작업 스케줄링, 버퍼, 메시지 큐, 프린터 스풀링.
      - **차이점**: 데이터 접근 방식 (LIFO vs FIFO)과 그로 인한 사용처.

    - **꼬리 질문: 두 스택으로 큐 구현? 두 큐로 스택 구현?**
      - **답변**:
        - **두 스택으로 큐**: `stack1`(enqueue용), `stack2`(dequeue용). Dequeue 시 `stack2` 비었으면 `stack1` 요소 모두 `stack2`로 옮긴 후 pop.
        - **두 큐로 스택**: `queue1`(주 저장소), `queue2`(임시). Pop 시 `queue1` 요소 하나 남을 때까지 `queue2`로 옮기고, `queue1` 마지막 요소 반환 후 `queue1`과 `queue2` 역할 스왑.

4.  **트리 기본 용어(루트, 노드, 간선, 깊이, 높이, 차수 등) 설명? 이진 트리와 이진 탐색 트리 차이점?**

    - **답변**:

      - **트리 기본 용어**:
        - **노드**: 데이터와 자식 링크 가진 요소. **루트**: 최상위 부모 없는 노드. **간선**: 노드 연결선.
        - **깊이**: 루트에서 특정 노드까지 경로 길이. **높이**: 특정 노드에서 가장 먼 리프까지 경로 길이.
        - **차수**: 노드의 자식 수. **리프**: 자식 없는 노드.
      - **이진 트리**: 각 노드가 최대 2개의 자식(왼쪽/오른쪽 구분) 가짐. 값 제약 없음.
      - **이진 탐색 트리 (BST)**: 이진 트리의 일종. **순서 규칙** (왼쪽 자식 < 부모 < 오른쪽 자식) 만족. 효율적 검색/삽입/삭제 (평균 O(log N)). 중위 순회 시 정렬.
      - **차이점**: BST는 이진 트리에 '값의 정렬 규칙'을 추가하여 검색 효율을 높인 구조.

    - **꼬리 질문: BST 평균/최악 탐색 시간 복잡도? 최악 경우 개선 방법(AVL, 레드-블랙 트리)?**
      - **답변**:
        - **BST 시간 복잡도**: 평균 O(log N), 최악 O(N) (편향 트리 시).
        - **최악 경우 개선 (균형 BST)**: 삽입/삭제 시 트리 균형 자동 조절하여 높이를 O(log N)으로 유지.
          - **AVL 트리**: 모든 노드의 좌우 서브트리 높이 차이(균형 인수)를 -1, 0, 1로 엄격히 유지. 회전 빈번 가능.
          - **레드-블랙 트리**: 노드에 레드/블랙 색상 부여, 특정 규칙 만족. AVL보다 덜 엄격, 삽입/삭제 성능 유리한 경우 많음. Java `TreeMap` 등에서 사용.

5.  **그래프 자료 구조 정의, 종류(방향/무방향, 가중치/비가중치)? 표현 방법(인접 행렬, 인접 리스트) 비교 설명?**

    - **답변**:

      - **그래프 정의**: 정점(Vertex) 집합과 간선(Edge) 집합으로 구성된 비선형 구조. 관계/연결 표현.
      - **종류**:
        - **방향/무방향**: 간선 방향성 유무.
        - **가중치/비가중치**: 간선에 가중치(비용, 거리 등) 유무.
      - **표현 방법**:
        - **인접 행렬**: N x N 배열. `matrix[i][j]`는 정점 i, j 간선 유무(또는 가중치).
          - **장점**: 간선 존재 확인 O(1). 밀집 그래프 유리.
          - **단점**: 공간 O(V^2) (희소 그래프 시 낭비). 한 정점 인접 정점 찾기 O(V).
        - **인접 리스트**: 각 정점별 인접 정점 리스트 저장.
          - **장점**: 공간 O(V+E) (희소 그래프 유리). 한 정점 인접 정점 찾기 O(Degree(v)).
          - **단점**: 간선 존재 확인 O(Degree(v)). 밀집 그래프 시 비효율 가능.

    - **꼬리 질문: DFS와 BFS 작동 방식, 시간 복잡도? 각각 유용한 상황?**
      - **답변**:
        - **DFS (깊이 우선 탐색)**: 시작 정점에서 한 방향으로 최대한 깊이 탐색 후 막히면 백트래킹. 스택 또는 재귀 사용.
        - **BFS (너비 우선 탐색)**: 시작 정점에서 가까운 정점부터 순차적 탐색. 큐 사용.
        - **시간 복잡도 (둘 다)**: 인접 행렬 O(V^2), 인접 리스트 O(V+E).
        - **유용한 상황**:
          - **DFS**: 경로 찾기(최단 경로 X), 사이클 탐지, 위상 정렬, 연결 요소.
          - **BFS**: 최단 경로(비가중치 그래프), 네트워크 브로드캐스팅, 두 노드 간 최단 거리.
