# 목차

- 목차
- [01 / 협력하는 객체들의 공동체](#01--협력하는-객체들의-공동체)
- [02 / 이상한 나라의 객체](#02--이상한-나라의-객체)
- [03 / 타입의 추상화](#03--타입과-추상화)
- [04 / 역할, 책임, 협력](#04--역할-책임-협력)

  <br>

# 01 / 협력하는 객체들의 공동체

# 🆕 새롭게 알게 된 점

> ✅ 기존에 몰랐던 개념이나 새로운 시각이 생긴 부분  
> 💡 객체지향을 ‘클래스 중심’이 아니라 ‘객체 중심’으로 바라보는 것의 중요성

- 기존 관점 : 클래스를 설계도로 보는 시각의 문제점
  - 객체지향을 클래스의 구조적 관계로만 바라보면, 정적인 설계에 초점이 맞춰진다.
  - 저자는 UML의 가장 대표적인 다이어그램으로 클래스 다이어그램을 꼽는 사람들이 많다고 했다.
  - 클래스 다이어 그램을 중심으로 시스템을 설계하면, 유연성과 확장성이 부족해질 수 있다.
  - 따라서 실행될 때 객체들이 협력하는 방식이 아니라, 단순한 데이터 구조처럼 보게 된다.

### 1️⃣ 클래스 중심 사고 (Class-Oriented Thinking)

- **정적인 구조 설계**에 초점
- 객체는 **단순한 데이터 저장소** 역할
- 협력 관계가 명확하지 않음 → 외부에서 직접 객체를 조작해야 함

#### 🔹 예제 (클래스 중심)

```java
class User {
    private String name;
    private String email;
    // 단순 데이터 저장소 역할
}

public class Main {
    public static void main(String[] args) {
        User sender = new User("Alice", "alice@example.com");
        User receiver = new User("Bob", "bob@example.com");

        // 메시지 처리 로직이 객체 외부에 존재
        System.out.println(sender.getName() + " -> " + receiver.getName() + ": '안녕!'");
    }
}
```

<br>

- 새로운 시각 : 객체를 지향하라
  - 객체지향은 클래스가 아니라 객체들이 협력하는 방식에 초점을 맞춰야 한다.
  - 중요한 것은 **어떤 클래스가 필요한가?가 아니라 "어떤 객체들이 어떤 메시지를 주고 받으며 협력하는가?"** 이다.
  - 객체들은 서로 메시지를 주고받으며 협력하고, 이를 통해 시스템이 동적으로 동작한다.
  - 협력관계를 기반으로 설계하면, 확장성과 유지보수성이 높은 유연한 시스템을 만들 수 있다!

### 2️⃣ 객체 중심 사고 (Object-Oriented Thinking)

- **메시지를 주고받으며 협력하는 객체들의 공동체**
- 객체는 **자율적으로 행동**하며 협력 가능
- 협력 관계가 명확하여 유지보수 및 확장성 향상

#### 🔹 예제 (객체 중심)

```java
class User {
    private String name;
    private String email;

    public void sendMessage(User receiver, String message) {
        receiver.receiveMessage(this, message);
    }

    public void receiveMessage(User sender, String message) {
        System.out.println(sender.getName() + " -> " + this.getName() + ": " + message);
    }
}

public class Main {
    public static void main(String[] args) {
        User alice = new User("Alice", "alice@example.com");
        User bob = new User("Bob", "bob@example.com");

        alice.sendMessage(bob, "안녕!");
        bob.sendMessage(alice, "반가워!");
    }
}
```

### 3️⃣ 비교 요약

| 비교 항목       | 클래스 중심 사고            | 객체 중심 사고                        |
| --------------- | --------------------------- | ------------------------------------- |
| **설계 방식**   | 데이터 보관 중심            | 협력과 메시지 교환 중심               |
| **객체의 역할** | 수동적 (데이터 저장)        | 자율적 (스스로 행동)                  |
| **메시지 처리** | 외부에서 직접 처리          | 객체 스스로 처리                      |
| **유지보수성**  | 기능 추가 시 코드 변경 많음 | 기능 추가 시 내부만 수정 가능         |
| **확장성**      | 역할 추가가 어려움          | 역할 추가가 유연함 (다형성 활용 가능) |

    > ✅ 책의 핵심 내용을 요약 & 정리

📖 **핵심 내용 요약**

### 객체지향은 협력하는 객체들의 공동체이다.

- 객체지향이란 **객체들 간의 협력**을 중심으로 시스템을 구성하는 방법이다.
- 개별 객체는 **역할**을 가지며, 역할을 통해 **협력**에 기여한다.
- **책임**을 수행하기 위해 객체는 다른 객체와 **메시지**를 주고 받는다.

### 객체는 공동체 안에서 협력한다.

- 어떠한 객체도 섬이 아니다.
  - 객체는 혼자 존재하는 것이 아니라 다른 객체와 상호작용해야 한다.
- 애플리케이션의 기능은 객체들의 협력으로 구현된다.
  - 기능은 작은 책임으로, 객체들은 이 책임을 수행하며 서로 협력한다.

### 객체의 자율성과 캡슐화

- 객체는 다른 객체의 요청을 듣지만, 명령을 따르는 것이 아니라 응답할 뿐이다.
- 객체는 어떤 요청을 어떻게 처리할지 스스로 결정해야 한다.
- 객체는 **상태와 행동**을 함께 가지며, 이를 통해 자율성을 유지한다.
- 객체의 자율성은 **캡슐화**를 통해 보장된다.

  - 객체의 내부 상태는 외부에서 직접 접근할 수 없고, 공개된 인터페이스를 통해서만 상호작용이 가능함.

  </br>

---

</br>

# ❓ **어려웠거나 이해가 부족했던 부분**

## 1. 역할과 책임의 의미, 중요성

### 역할이 없다면?

- 객체지향을 처음 배울때 많은 사람들이 클래스 설계를 중심으로 생각한다. 예를 들어, 게임을 만든다고 하면 **플레이어, 몬스터, NPC** 같은 구체적인 개념부터 떠올리게 된다.

```java
class Player {
    void attack() { ... }
}

class Monster {
    void defend() { ... }
}
```

- 물론 이런 방식은 단순하고 직관적이지만, **유연성**이 부족하다. 새로운 몬스터 유형이 생기거나, NPC도 공격할 수 있게 된다면 기존 코드를 뒤집어야 한다.

### 역할 중심 설계: 유연성 및 확장성 확보 가능

- "플레이어가 공격을 한다"가 아니라, "어떤 대상(객체)이 공격할 수 있다"라는 역할을 먼저 정의하면 좋다.

```java
interface Attacker {
    void attack();
}

class Player implements Attacker {
    @Override
    public void attack() {
        System.out.println("플레이어가 공격합니다.");
    }
}

class NPC implements Attacker {
    @Override
    public void attack() {
        System.out.println("NPC가 공격합니다.");
    }
}

public class Game {
    public static void main(String[] args) {
        Attacker attacker1 = new Player();
        Attacker attacker2 = new NPC();

        attacker1.attack();  // "플레이어가 공격합니다."
        attacker2.attack();  // "NPC가 공격합니다."
    }
}
```

### 🔍 이 코드의 의미

- Attacker라는 역할을 정의하고, Player와 NPC가 그 역할을 수행
- 💡 결론
- 객체지향 설계에서 역할이 중요한 이유는 유연성과 확장성을 보장하기 때문이다.
- 역할이 없다면 코드가 특정 구현에 종속되어 유지보수가 어렵다.

## 2. 객체는 어떻게 협력하는가?

- 객체는 서로 메소드를 호출하며 협력한다.
- 하지만 직접적인 명령이 아닌 요청을 보내야한다.

### ❌ 직접적인 명령 (안 좋은 예)

```java
class Chef {
    void cook() {
        System.out.println("요리를 합니다.");
    }
}

class Restaurant {
    Chef chef = new Chef();

    void orderFood() {
        chef.cook();  // 직접적으로 cook()을 호출
    }
}
```

- Restaurant 객체가 Chef 객체의 cook()을 직접 호출 → 결합도가 높아짐
- 만약 Chef가 변경되면 Restaurant도 변경해야 함

### ✅ 메시지를 통한 협력 (좋은 예)

```java
class Chef {
    void cook() {
        System.out.println("요리를 합니다.");
    }
}

class Restaurant {
    private Chef chef;

    public Restaurant(Chef chef) {  // 의존성 주입 (Dependency Injection)
        this.chef = chef;
    }

    void orderFood() {
        chef.cook();  // Chef에게 요리를 요청 (메시지 전달)
    }
}

public class Main {
    public static void main(String[] args) {
        Chef chef = new Chef();
        Restaurant restaurant = new Restaurant(chef);
        restaurant.orderFood();
    }
}
```

- Restaurant는 Chef 객체가 어떻게 요리를 하는지 신경 쓰지 않음 (단순히 "요리해줘"라고 요청할 뿐)
- 만약 Chef가 바뀌어도 Restaurant는 영향을 받지 않음 (결합도가 낮아짐)

### 결합도와 응집도

- 결합도(Coupling): 객체 간의 의존성을 나타내는 정도
- 응집도(Cohesion): 클래스 내부의 요소들이 얼마나 밀접하게 관련되어 있는가?
- => 결합도는 낮을수록 응집도는 높을수록 좋다.

💡 **토론해 보고 싶은 질문**

- 객체의 자율성이 보장되지 않으면 어떤 문제가 생길까..?

</br>

---

</br>

# 🌟 **인상 깊었던 책의 내용**

> 📝 특히 기억에 남는 문장이나 사례  
> 📝 왜 인상 깊었는지, 어떻게 적용할 수 있을지 고민

📌 **기억에 남는 문장**

- _클래스는 객체들의 협력관계를 코드로 옮기는 도구에 불과하다._
  - 중요한 것은 객체들이 어떻게 협력하는가 이다.

🔎 **적용 방법 고민**

- (이 내용을 어떻게 적용할 수 있을지 생각 정리)

</br>

---

</br>

# 02 / 이상한 나라의 객체

> ✅ 책의 핵심 내용을 요약 & 정리

📖 **핵심 내용 요약**

이 책에서는 객체지향 패러다임의 핵심 개념을 다루고 있다. 객체지향이란 현실 세계의 복잡성을 줄이기 위해 **지식을 추상화**하고, 그 지식을 객체 안에 **캡슐화**하는 방식으로 소프트웨어를 설계하는 것이다.

객체의 주요 속성으로는 **상태(state)**, **행동(behavior)**, **식별자(identity)** 가 있다.

- **상태**: 객체의 내부 값으로, 상태를 통해 객체의 현재 상황을 파악할 수 있다. 상태 개념 덕분에 모든 행동의 이력을 설명할 필요 없이 현재를 기반으로 예측이 가능하다. 예를 들어, 게임 캐릭터의 체력(HP)은 캐릭터의 상태를 나타내며, 체력이 0이 되면 게임에서 패배하는 방식으로 상태가 행동에 영향을 미친다.
- **행동**: 객체는 스스로 행동하여 상태를 변화시킨다. 행동이 없다면 객체는 정적인 데이터와 다를 바 없다. 예를 들어, 게임 캐릭터는 공격을 하거나 아이템을 획득하는 행동을 수행할 수 있으며, 이러한 행동이 캐릭터의 상태를 변경하게 된다.
- **식별자**: 객체는 고유한 식별자를 가진다. 동일한 상태를 가진 두 개의 객체라도 식별자가 다르면 서로 다른 객체다. 예를 들어, 같은 능력치를 가진 두 개의 몬스터 객체가 있다고 해도 각각의 고유한 ID를 통해 구별할 수 있다.

책에서는 **상태 중심의 사고방식이 객체지향을 오해하게 만드는 함정**이 될 수 있다고 경고한다. 상태에 집중하면 객체가 외부와 협력하기 어려운 형태로 설계되며, 캡슐화가 약화될 수 있다. 대신 객체는 **행동을 중심으로** 바라봐야 한다.

또한 객체지향의 본질은 현실 세계를 단순 모방하는 것이 아니라, 현실과 다른 능동적인 객체를 창조하는 것이라는 점을 강조한다. 현실에서는 수동적인 개체가 소프트웨어에서는 능동적으로 동작할 수 있어야 한다.

---

# ❓ **어려웠거나 이해가 부족했던 부분**

- #### 1. 동등성과 동일성의 차이: 상태를 기반으로 같은지를 판단하는 '동등성'과 식별자로 객체를 구별하는 '동일성' 개념이 처음에는 헷갈렸다. 단순한 값과 객체의 차이를 이해하는 것이 중요할 듯하다.

  - 동등성 (Equality): 두 객체가 같은 상태를 가지면 동등하다고 판단한다.
    - 예를 들어, 두 개의 Point 객체가 (x=5, y=10)이라는 같은 값을 가지고 있다면 동등하다고 볼 수 있다.
  - 동일성 (Identity): 두 객체가 완전히 같은 메모리 주소를 참조하면 동일하다고 판단한다.

    - 즉, 같은 상태를 가지고 있어도 서로 다른 객체라면 동일하지 않다.

    ```java
    // 좌표(Point)를 표현하는 클래스
    class Point {
        private int x, y; // 상태 (x, y 좌표)

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }

        // equals() 메서드 재정의 - 상태(값)를 기준으로 비교
        @Override
        public boolean equals(Object obj) {
            // 동일한 객체인지 먼저 확인 (메모리 주소 비교)
            if (this == obj) return true;

            // null이거나 다른 클래스의 객체라면 false 반환
            if (obj == null || getClass() != obj.getClass()) return false;

            // 타입 변환 후 x, y 값이 같으면 동등하다고 판단
            Point point = (Point) obj;
            return this.x == point.x && this.y == point.y;
        }
    }

    public class Main {
        public static void main(String[] args) {
            // 두 개의 서로 다른 Point 객체 생성 (값은 같음)
            Point p1 = new Point(5, 10);
            Point p2 = new Point(5, 10);

            // 같은 객체를 참조하는 p3
            Point p3 = p1;

            // 1. equals()를 사용한 동등성 비교 (값을 비교)
            System.out.println("p1과 p2는 동등한가? " + p1.equals(p2)); // true (값이 같음)

            // 2. == 연산자를 사용한 동일성 비교 (메모리 주소 비교)
            System.out.println("p1과 p2는 동일한가? " + (p1 == p2)); // false (다른 객체)

            // 3. 같은 객체를 참조하는 경우 (동일성 비교)
            System.out.println("p1과 p3는 동일한가? " + (p1 == p3)); // true (같은 객체)
        }
    }
    ```

    ## 📌 코드 흐름 설명

    ### 객체 비교 방식

    - `p1.equals(p2)` → **동등성 검사**
    - `p1`과 `p2`는 같은 `(x=5, y=10)` 값을 가지고 있기 때문에 **true**.
    - `p1 == p2` → **동일성 검사**
    - `p1`과 `p2`는 서로 다른 객체이므로 **false**.
    - `p1 == p3` → **동일성 검사**
    - `p3`는 `p1`을 그대로 참조하고 있으므로 **true**.

    ### `equals()` 재정의 이유

    - 기본적으로 `equals()`를 재정의하지 않으면, `Object` 클래스의 `equals()`는 `==` 와 같은 동작을 한다.
    - 즉, **값이 같더라도 다른 객체라면 false가 나옴**
    - 우리가 `equals()`를 오버라이딩하면 **객체의 상태(값)를 비교할 수 있음**.

    ## 설명 요약

    ### 1. **동등성 (Equality)**

    - `equals()` 메서드를 사용해 **객체의 상태(값)를 비교**.
    - **예:** 같은 좌표 `(x=5, y=10)` 를 가진 두 개의 `Point` 객체는 **동등**하다.
    - `p1.equals(p2) == true` ✅ (값이 같으면 true)

    ### 2. **동일성 (Identity)**

    - `==` 연산자를 사용해 **객체의 메모리 주소(참조)를 비교**.
    - **예:** `p1`과 `p3`는 같은 객체를 가리키므로 **동일**하다.
    - `p1 == p3 == true` ✅ (같은 객체를 참조)

- #### 2. **객체를 행동 중심으로 바라보는 방법**

  - 객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라 보는 것이다.
  - 기존에 상태를 중심으로 객체를 설계하던 방식과 달리, 행동을 먼저 정의하는 것이 익숙하지 않다. 실무에서는 어떤 방식으로 적용하는 것이 좋을지 고민이 된다.
  - 책에서는 다음과 같은 이유로 상태를 중심으로 객체를 바라보는 것이 좋지 않다 한다.

  ```md
  1. 상태를 먼저 결정할 경우 캡슐화가 저해된다.
  2. 객체를 협력자가 아닌 고립된 섬으로 만든다.
  3. 재사용성이 저하된다.
  ```

  ❌ 상태 중심 설계 (잘못된 방식)

  ```java
  class ShoppingCart {
    public List<String> items = new ArrayList<>(); // 상태 공개 (캡슐화 X)
  }
  ```

  - items가 public으로 선언되어 있기 때문에 외부에서 직접 수정 가능하다.
  - 이 방식은 데이터만 저장할 뿐, 행동(비즈니스 로직)이 없다.

  ✅ 행동 중심 설계 (객체지향적인 방식)

  ```java
  class ShoppingCart {
    private List<String> items = new ArrayList<>(); // 상태를 숨기고 행동을 통해 접근

    public void addItem(String item) {
        items.add(item);
        System.out.println(item + "이(가) 장바구니에 추가되었습니다.");
    }

    public void removeItem(String item) {
        items.remove(item);
        System.out.println(item + "이(가) 장바구니에서 제거되었습니다.");
    }

    public void displayItems() {
        System.out.println("현재 장바구니: " + items);
    }
  }
  ```

  - 이제 장바구니 객체는 addItem(), removeItem() 같은 행동을 통해서만 수정할 수 있다.
  - 객체의 내부 상태를 숨기고, 행동을 통해서만 상태를 변경하도록 강제한다.

  📌 핵심 정리

  - 상태 중심 설계는 객체를 단순한 데이터 저장소로 만듦 → 캡슐화가 깨짐
  - 행동 중심 설계는 객체가 스스로 행동할 수 있도록 만듦 → 객체의 역할이 분명해짐

💡 **토론해 보고 싶은 질문**

1. 객체를 설계할 때 상태 중심이 아니라 행동 중심으로 접근해야 한다고 했다. 그렇다면 상태 중심으로 접근하는 것이 유리한 경우도 있을까?

- 데이터 중심의 객체(VO, DTO, 엔티티) 는 상태가 중요한 역할을 하며, 행동이 거의 필요하지 않다.
- 캐시 시스템처럼 상태가 핵심적인 역할을 하는 경우에도 상태 중심 설계가 적절하다.
- 하지만 일반적인 객체 설계에서는 행동을 중심으로 생각하는 것이 더 객체지향적이다.

---

# 🌟 **인상 깊었던 책의 내용**

📌 **기억에 남는 문장**

> "소프트웨어 객체를 창조할 때 우리는 현실 세계의 객체를 모방하는 것이 아니라, 현실 세계의 객체와 전혀 다른 특징을 부여하는 것이 일반적이다."(67p 의인화 부분)

🔎 **적용 방법 고민**  
이 문장을 통해 현실 세계의 개념을 그대로 코드로 옮기는 것이 아니라, 프로그래밍의 목적과 요구 사항에 맞게 변형하는 것이 필요하다는 점을 다시 한번 깨달았다. 예를 들어, **게임 속 캐릭터 객체**를 설계할 때 단순히 체력과 능력치를 저장하는 것이 아니라, 공격하거나 방어하는 동작을 수행할 수 있도록 설계하는 것이 더 객체지향적인 접근이 될 것이다.

💻 **객체지향을 이해하기 위한 간단한 코드 예제**

```java
// 게임 캐릭터를 표현하는 클래스
class GameCharacter {
    private String name;  // 캐릭터의 이름 (식별자 역할)
    private int health;   // 체력 (상태)

    // 생성자: 캐릭터를 만들 때 이름과 체력을 설정
    public GameCharacter(String name, int health) {
        this.name = name;
        this.health = health;
    }

    // 행동: 다른 캐릭터를 공격하는 메서드
    public void attack(GameCharacter target) {
        System.out.println(name + "이(가) " + target.getName() + "을(를) 공격합니다!");
        target.takeDamage(10);  // 공격하면 대상의 체력을 감소
    }

    // 행동: 피해를 입으면 체력이 감소하는 메서드
    public void takeDamage(int damage) {
        health -= damage;
        System.out.println(name + "이(가) " + damage + "의 피해를 입었습니다. 남은 체력: " + health);
    }

    // 캐릭터의 이름을 반환하는 메서드
    public String getName() {
        return name;
    }
}

// 메인 클래스 (게임 실행)
public class Main {
    public static void main(String[] args) {
        // 두 개의 캐릭터 객체 생성
        GameCharacter hero = new GameCharacter("용사", 100);
        GameCharacter monster = new GameCharacter("고블린", 50);

        // 전투 시작
        hero.attack(monster);  // 용사가 고블린을 공격
        monster.attack(hero);  // 고블린이 용사를 공격
    }
}
```

`GameCharacter` 객체는 단순한 데이터 저장소가 아니라, **공격하고 피해를 입는 능동적인 행동을 수행할 수 있도록 설계**되었다. 객체지향 설계의 핵심은 데이터를 단순히 보관하는 것이 아니라, 객체가 **행동을 통해 상태를 변경하는 것**이라는 점을 강조한다!

</br>

---

</br>

# 03 / 타입과 추상화

# 🆕 새롭게 알게 된 점

> ✅ 기존에 몰랐던 개념이나 새로운 시각이 생긴 부분  
> 💡 객체지향을 '클래스 중심'이 아니라 '객체 중심'으로 바라보는 것의 중요성

- 객체의 타입은 객체가 수행하는 **행동(behavior)** 에 의해 결정된다.
- 상태(state)는 행동을 수행하기 위한 보조적인 요소일 뿐, 객체를 정의하는 핵심이 아니다.
- **캡슐화(encapsulation)** 의 핵심은 데이터를 숨기는 것이 아니라, **행동을 통해 접근할 수 있도록 만드는 것**이다.
- 행동을 기준으로 타입을 나누면, 시스템의 변경에 유연하게 대처할 수 있다.
- 객체는 서로 협력하기 위해 존재하며, 협력은 메시지를 주고받는 방식으로 이루어진다.
- 객체를 설계할 때 **책임(responsibility)** 을 먼저 정의하고, 데이터를 나중에 고려하는 것이 더 유리하다.
- 객체지향에서 중요한 것은 **추상화(abstraction)** 를 올바르게 활용하는 것이다.

📖 **핵심 내용 요약**

- **추상화**는 개념을 단순화하는 과정이며, 복잡한 객체의 공통점을 찾아 타입을 정의하는 것이 핵심이다.
- 개념의 세 가지 관점:
  - **심볼(Symbol)**: 개념을 나타내는 간략한 명칭
  - **내연(Intension)**: 개념을 정의하는 속성과 행동
  - **외연(Extension)**: 개념에 속하는 모든 객체들의 집합
- 객체의 타입을 결정하는 것은 **행동**이다. 내부 데이터가 동일해도, 행동이 다르면 다른 타입으로 분류된다.
- **일반화(Generalization)** 는 여러 개념에서 공통점을 추출해 상위 개념을 만드는 과정, **특수화(Specialization)** 는 상위 개념을 세분화하는 과정이다.
- **정적 모델(Static Model)** 은 시스템의 구조를 나타내고, **동적 모델(Dynamic Model)** 은 객체 간의 상호작용을 표현한다.

## 📌 **예제 코드: 전투 게임에서의 행동 중심 객체 설계**

### 🔹 **잘못된 설계 (데이터 중심)**

```java
class Warrior {
    String name;
    int health;
    String attackType;

    public Warrior(String name, int health, String attackType) {
        this.name = name;
        this.health = health;
        this.attackType = attackType;
    }

    public void attack() {
        if (attackType.equals("sword")) {
            System.out.println(name + "이(가) 검으로 공격한다!");
        } else if (attackType.equals("bow")) {
            System.out.println(name + "이(가) 활을 쏜다!");
        }
    }
}
```

- `attackType`을 문자열로 관리하여 **새로운 공격 방식이 추가될 때마다 조건문을 수정해야 함**
- 데이터가 행동을 결정하고 있음 → 유지보수 어려움

### 🔹 **행동 중심 설계 (객체지향적 접근)**

```java
interface Attacker {
    void attack();
}

// 검을 사용하는 전사
class SwordWarrior implements Attacker {
    @Override
    public void attack() {
        System.out.println("검을 휘둘러 공격한다!");
    }
}

// 활을 사용하는 궁수
class Archer implements Attacker {
    @Override
    public void attack() {
        System.out.println("활을 쏘아 공격한다!");
    }
}

public class Battle {
    public static void main(String[] args) {
        Attacker warrior = new SwordWarrior();
        Attacker archer = new Archer();

        warrior.attack(); // "검을 휘둘러 공격한다!"
        archer.attack();  // "활을 쏘아 공격한다!"
    }
}
```

✅ **행동(attack())을 중심으로 타입을 설계** → 새로운 공격 방식 추가 시 기존 코드 변경 없이 확장 가능  
✅ **다형성을 활용하여 유연한 코드 작성 가능**

# ❓ **어려웠거나 이해가 부족했던 부분**

은 별로 없었다.

💡 **토론해 보고 싶은 질문**

- **"추상화 vs 구체화: 언제 추상화하고 언제 구체화할까?"**

  - 추상화는 공통점을 찾아내어 구조를 단순화하는 과정이고, 구체화는 특정한 기능을 명확히 구현하는 과정이다. 너무 이른 추상화는 불필요한 복잡성을 초래할 수 있다. 핵심은 변할 가능성이 높은 부분을 중심으로 추상화를 적용하는 것이다.

- **"인터페이스와 클래스의 추상화 차이점: 어느 경우에 적합할까?"**

  - 인터페이스는 행동을 정의하는 역할이며, 다형성을 활용할 때 유용하다. 클래스는 상태와 행동을 함께 가지며, 특정한 객체의 구현을 포함할 때 적합하다. 인터페이스는 객체 간의 결합도를 낮추고, 클래스는 구체적인 구현을 포함하는 데 집중해야 한다.

- **"너무 과도한 추상화는 오히려 코드를 이해하기 어렵게 하지 않을까?"**
  - 위에서 언급했듯이, 적절한 수준을 결정하는 기준이 모호할 수 있다. 그렇다면 어떻게 적절한 수준을 결정해야 할까?
    1. **변경 가능성이 높은 부분을 추상화**한다. 너무 이른 추상화는 오히려 코드를 복잡하게 만들 수 있으므로, 실제 변경이 필요한 부분을 중심으로 진행하는 것이 중요하다.
    2. **객체의 책임을 명확하게 분리**한다. 단일 책임 원칙(SRP)을 적용하여 객체가 하나의 역할에 집중하도록 만든다.
    3. **실제 코드의 복잡도를 고려**한다. 코드가 간결해지고 이해하기 쉬운 방향으로 추상화를 적용해야 한다. 너무 많은 계층을 만들면 오히려 가독성이 떨어진다.
    4. **유지보수성을 고려**한다. 향후 확장이 필요할 것으로 예상되는 부분을 먼저 추상화하고, 불필요한 추상화는 지양한다.

---

# 🌟 **인상 깊었던 책의 내용**

📌 **기억에 남는 문장**

> "일단 컴퓨터를 조작하는 것이 추상화를 구축하고, 조작하고, 추론하는 것에 관한 모든 것이라는 것을 깨닫고 나면 훌륭한 컴퓨터 프로그램을 작성하기 위한 중요한 전제 조건은 추상화를 정확하게 다루는 능력이라는 것이 명확해진다." (pg.72)

🔎 **적용 방법 고민**

- 객체의 행동을 먼저 정의하고, 상태는 최소한으로 유지해야 한다.
- 객체 간의 협력을 설계할 때 **메시지를 먼저 고려**하고, 그에 맞는 인터페이스를 정의하는 것이 중요하다.
- 추상화를 적용할 때, **변화 가능성이 높은 부분을 먼저 추상화**하여 유지보수성을 높이는 전략을 사용해야 한다.

---

</br>

# 04 / 역할, 책임, 협력

---

## 🆕 새롭게 알게 된 점

> ✅ 기존에 몰랐던 개념이나 새로운 시각이 생긴 부분  
> 💡 객체지향을 ‘클래스 중심’이 아니라 ‘객체 중심’으로 바라보는 것의 중요성

- 이전에는 객체지향 설계를 클래스 단위로만 생각하며 데이터나 메서드를 중심으로 객체를 구성했다. 하지만 책에서는 객체지향을 **협력하는 객체 중심**으로 바라보고 있다. 클래스의 세부 구현보다, 객체들이 협력을 통해 책임을 주고받으며 상호작용하는 것이 설계의 핵심이라는 점을 알았다.
- 특히 **책임**과 **역할** 개념이 설계의 핵심 요소임을 깨달았다. 역할을 정의함으로써 협력을 추상화하고 객체 간의 대체 가능성을 높여 설계의 유연성을 높일 수 있다.
- 객체의 존재 목적이 데이터를 저장하는 것이 아니라 협력 과정에서 책임을 수행하기 위한 행동을 제공하기 위함이라는 시각이 기존 생각과 크게 달랐다.

---

## 📖 핵심 내용 요약

- **협력**  
  협력은 객체들이 요청과 응답을 통해 상호작용하는 과정이다. 객체 간 협력은 하나의 요청이 다른 객체의 응답으로 이어지는 연쇄적 흐름으로 구성된다.

- **책임**  
  책임이란 객체가 특정 요청에 응답하거나 행동을 수행할 의무를 의미한다. 객체의 책임은 크게 두 가지로 나뉜다.

  - **하는 것(Doing)**: 객체가 스스로 수행하거나 다른 객체를 조작 및 제어하는 행동
  - **아는 것(Knowing)**: 객체가 가지고 있는 정보나 연관된 객체들에 대한 지식

- **메시지**  
  객체가 책임을 수행하도록 다른 객체에게 요청을 보내는 행위를 메시지 전송이라 한다. 객체는 메시지를 수신한 경우에만 책임을 수행한다. 메시지는 객체 간 협력의 핵심 수단이다.

- **역할**  
  역할은 객체가 협력 과정에서 수행할 수 있는 책임들의 집합이다. 역할을 통해 다양한 객체들이 동일한 협력에 참여할 수 있으며, 이를 통해 유연성과 재사용성을 높일 수 있다. 객체가 동일한 역할을 수행하기 위해서는 메시지 수신과 행동이 호환돼야 한다.

- **협력의 추상화와 대체 가능성**  
  역할을 이용하면 협력 과정을 추상화할 수 있고, 협력 과정에 여러 객체를 대체 가능하도록 설계할 수 있다. 객체는 역할이 요구하는 책임을 모두 수행할 수 있는 한 협력 과정에서 얼마든지 대체될 수 있다.

- **객체의 모양을 결정하는 협력**  
  올바른 객체 설계를 하려면 객체의 책임(행동)을 우선 결정하고, 이후에 필요한 데이터를 고려한 뒤 클래스를 설계한다. 데이터는 객체가 책임을 수행하기 위한 부수적 요소일 뿐, 객체의 핵심은 책임을 수행하는 행동에 있다.

- **객체지향 설계 기법**

  - **책임-주도 설계(Responsibility-Driven Design, RDD)**: 시스템의 책임을 객체의 책임으로 나누고, 객체 간 협력에 따라 책임을 할당해 나가는 설계 방식이다.
  - **디자인 패턴(Design Pattern)**: 전문가들이 반복적으로 사용하는 객체 간 협력 구조를 정리한 것으로, 문제 해결을 위한 역할, 책임, 협력의 표준 템플릿이다.
  - **테스트-주도 개발(Test-Driven Development, TDD)**: 실패하는 테스트를 먼저 작성한 뒤 이를 통과하도록 코드를 작성하는 방식이다. 이 과정에서 객체의 책임을 명확하게 할 수 있다.

<div align="center">
    <img src="https://github.com/user-attachments/assets/376a38b6-6730-4173-a63a-ba5789a7db6c" alt="Image" />
</div>
- **책임-주도 설계(RDD)란?**

- 시스템이 수행해야 하는 기능을 작은 책임 단위로 세분화하고, 이를 적절한 객체나 역할에 할당하여 협력을 구축하는 설계 방식이다.
- 객체의 상태보다는 행동을 중시하며, 객체 간 협력 구조를 명확하게 정의하는 것이 목표다.
- 명확한 책임 분리를 통해 높은 응집도와 낮은 결합도를 유지할 수 있어 유지보수성과 확장성이 뛰어나다.
- **RDD의 주요 단계:**

  1. 시스템의 주요 기능을 분석하고 책임을 도출한다.
  2. 도출된 책임을 적절한 역할과 객체로 나눈다.
  3. 역할 간 협력 구조를 정의하여 상호작용을 설계한다.
  4. 객체들이 각자의 책임을 수행하도록 세부 구현을 진행한다.

- **테스트-주도 개발(TDD)란?**

  - 먼저 실패하는 테스트를 작성한 후, 이를 통과할 최소한의 코드를 작성하는 방식으로 진행된다.
  - 단순히 테스트를 먼저 작성하는 것이 아니라, **요구사항을 명확하게 정의**하고 이를 코드로 구현하는 과정이다.
  - 테스트를 기반으로 개발이 진행되므로, 코드의 신뢰성이 높아지고 유지보수성이 향상된다.
  - **TDD의 주요 단계:**
    1. 실패하는 테스트를 작성한다.
    2. 테스트를 통과하는 최소한의 코드를 작성한다.
    3. 중복을 제거하고 개선하기 위해 리팩토링을 수행한다.
    4. 위의 과정을 반복하여 기능을 완성해 나간다.

- **RDD vs TDD 비교**

| 항목      | 책임-주도 설계(RDD)                          | 테스트-주도 개발(TDD)                  |
| --------- | -------------------------------------------- | -------------------------------------- |
| 초점      | 객체의 책임과 협력                           | 테스트 기반의 개발                     |
| 접근 방식 | 역할과 책임을 먼저 정의하고 구현             | 테스트를 먼저 작성하고 코드 구현       |
| 장점      | 객체 간 협력 관계가 명확해지고 유연성이 증가 | 신뢰성 높은 코드, 리팩토링 용이        |
| 단점      | 객체 간 협력 설계가 복잡할 수 있음           | 초기에 테스트 작성 비용이 높을 수 있음 |
| 적용 사례 | 대규모 시스템, 도메인 중심 설계              | 안정성이 중요한 프로젝트, 애자일 개발  |

---

## RDD와 TDD의 조합 전략

- **초기 단계에서 RDD를 적용하여 객체의 책임과 협력을 명확히 설계한 후, TDD를 활용하여 개발 진행**
- TDD를 통해 주요 협력 관계를 검증하고, 지속적인 리팩토링을 통해 유연한 시스템 구축 가능
- 대규모 프로젝트에서는 **RDD → TDD 순서**로 진행하여 확장성과 신뢰성을 동시에 확보할 수 있음

<div align="center">
    <img src="https://github.com/user-attachments/assets/4e6baf6d-42e7-4fe0-bd01-cbc4dbbb744e" alt="Image" />
</div>

---

## 예시 자바 코드 (RDD와 TDD 적용 예제)

아래의 예제 코드는 기존의 "법정" 테마를 유지하면서, **책임-주도 설계(RDD)**와 **테스트-주도 개발(TDD)** 기법을 적용한 사례를 보여준다. 각 객체의 역할과 책임이 명확하게 정의되어 있으며, 주석을 통해 자세하게 설명하고 있다.

```java
// 패키지 선언 및 필요한 라이브러리 임포트 (실제 테스트 시 JUnit 라이브러리 필요)
// import org.junit.Test;
// import static org.junit.Assert.*;

// -------------------------------------
// 역할과 책임 정의 (RDD 적용)
// -------------------------------------

/**
 * Judge 인터페이스: 법정에서 판사의 역할을 담당하며, 증인을 호출하고 증언을 요청하는 책임을 가진다.
 */
interface Judge {
    // 증인을 호출하는 책임: 증인의 이름을 받아 증인을 찾아내도록 요청한다.
    void callWitness(String witnessName);

    // 증언 요청의 책임: 호출된 증인에게 증언을 요청한다.
    void requestTestimony(Witness witness);
}

/**
 * Witness 인터페이스: 증인의 역할을 담당하며, 법정에 입장하고 증언을 하는 책임을 가진다.
 */
interface Witness {
    // 법정에 입장하는 책임
    void enterCourt();

    // 증언을 수행하는 책임: 증언 내용을 반환한다.
    String giveTestimony();
}

// -------------------------------------
// 객체 구현 (RDD 적용)
// -------------------------------------

/**
 * WhiteRabbit 클래스: 증인을 찾아 호출하는 역할을 수행한다.
 * 책임: 주어진 증인 이름에 맞는 증인을 찾아 반환한다.
 */
class WhiteRabbit {
    // 증인을 찾는 메서드
    public Witness findWitness(String witnessName) {
        // 실제 시스템에서는 이름에 따라 다양한 증인을 찾아 반환할 수 있음.
        // 여기서는 예시로 항상 MadHatter(모자장수)를 반환한다.
        return new MadHatter();
    }
}

/**
 * QueenOfHearts 클래스: Judge 인터페이스를 구현한 판사 객체.
 * 책임: WhiteRabbit을 통해 증인을 호출하고, 증언을 요청한다.
 */
class QueenOfHearts implements Judge {
    private WhiteRabbit whiteRabbit;

    // 생성자를 통해 WhiteRabbit 의존성을 주입받는다.
    public QueenOfHearts(WhiteRabbit whiteRabbit) {
        this.whiteRabbit = whiteRabbit;
    }

    // 증인을 호출하는 책임 구현
    @Override
    public void callWitness(String witnessName) {
        System.out.println("여왕이 토끼에게 증인 '" + witnessName + "' 호출을 요청한다.");
        // WhiteRabbit을 이용하여 증인을 찾는다.
        Witness witness = whiteRabbit.findWitness(witnessName);
        // 증인이 법정에 입장하도록 요청 후 증언을 받는다.
        witness.enterCourt();
        requestTestimony(witness);
    }

    // 증언 요청의 책임 구현
    @Override
    public void requestTestimony(Witness witness) {
        System.out.println("여왕이 증인에게 증언을 요청한다.");
        // 증언을 받고 결과를 출력한다.
        String testimony = witness.giveTestimony();
        System.out.println("증언 내용: " + testimony);
    }
}

/**
 * MadHatter 클래스: Witness 인터페이스를 구현한 증인 객체.
 * 책임: 법정에 입장하고, 자신의 증언을 제공한다.
 */
class MadHatter implements Witness {
    // 법정 입장 구현
    @Override
    public void enterCourt() {
        System.out.println("모자장수가 증인석에 입장한다.");
    }

    // 증언 제공 구현
    @Override
    public String giveTestimony() {
        // 증언 내용은 간단한 문자열로 예시한다.
        return "모자장수가 알고 있는 비밀 증언";
    }
}

// -------------------------------------
// TDD: 테스트 코드 작성 (JUnit 사용 예제)
// -------------------------------------

/**
 * CourtTrialTest 클래스: TDD 방식을 적용하여 QueenOfHearts와 관련된 행동을 검증하는 테스트 케이스.
 * 실제 환경에서는 JUnit 프레임워크를 사용하여 실행한다.
 */
class CourtTrialTest {

    // 테스트 메서드 예시 (JUnit에서는 @Test 어노테이션 사용)
    // @Test
    public void testWitnessCallAndTestimony() {
        // 1. 실패하는 테스트를 먼저 작성하는 단계 (TDD 첫 단계)
        //    - 예상: 여왕이 증인을 호출하면, 증인이 법정에 입장하고 올바른 증언을 제공해야 함.

        // 2. 테스트를 통과하는 최소한의 코드를 작성하기 위한 객체 생성
        WhiteRabbit whiteRabbit = new WhiteRabbit();
        QueenOfHearts queen = new QueenOfHearts(whiteRabbit);

        // 3. 증인을 호출하는 메서드 실행 (이때 내부적으로 증인의 입장 및 증언 요청이 수행됨)
        queen.callWitness("모자장수");

        // 4. (실제 JUnit 테스트에서는) 증언 내용이나 객체 상태를 assert 구문으로 검증한다.
        // 예시: assertEquals("모자장수가 알고 있는 비밀 증언", witness.giveTestimony());
        // 여기서는 콘솔 출력으로 검증 과정을 확인할 수 있다.
    }

    // main 메서드를 통해 테스트를 간단히 실행할 수 있다.
    public static void main(String[] args) {
        CourtTrialTest test = new CourtTrialTest();
        test.testWitnessCallAndTestimony();  // 테스트 케이스 실행
    }
}
```

---

### 코드 설명

- **RDD 적용 부분:**

  - **Judge, Witness 인터페이스**를 통해 각 객체가 수행해야 하는 책임을 명확히 정의하였다.
  - **QueenOfHearts**는 판사로서, 증인을 호출하고 증언을 요청하는 책임을 수행하며, **WhiteRabbit**은 증인을 찾아 반환하는 역할을 담당한다.
  - **MadHatter**는 증인 역할을 수행하여 법정에 입장하고 증언을 제공한다.

- **TDD 적용 부분:**
  - **CourtTrialTest** 클래스는 테스트 주도 개발 방식을 적용한 예제로, 실패하는 테스트를 작성한 후 이를 통과하도록 구현을 진행하는 과정을 보여준다.
  - 실제 JUnit 환경에서는 `@Test` 어노테이션과 assert 구문을 활용해 객체들의 행동을 검증할 수 있으며, 본 예제에서는 콘솔 출력을 통해 검증 과정을 확인할 수 있다.

---

💡 **토론해 보고 싶은 질문**

- 대규모 시스템에서 협력을 식별하고 추상화하는 효과적인 방법은 무엇인가? 너무 많은 협력이 존재할 때 이를 관리하는 전략은?

  - **모듈화(Modularization)**: 협력 관계를 기능 단위로 분리하여 독립적인 모듈을 설계한다.
  - **계층화(Layering)**: 역할을 기반으로 시스템을 계층별로 나누어 복잡성을 줄인다.
  - **역할 기반 협력(RBAC, Role-Based Access Control)**: 객체가 수행할 수 있는 역할을 정의하고, 역할 단위로 협력을 관리한다.
  - **도메인 주도 설계(DDD, Domain-Driven Design)**: 도메인 모델을 기반으로 협력을 설계하여 유지보수성을 높인다.
  - **협력 패턴 적용**: 디자인 패턴을 활용하여 재사용 가능하고 확장 가능한 협력 구조를 구축한다.
  - **협력 시각화 도구 사용**: 복잡한 시스템에서는 UML 다이어그램이나 협력 시각화 툴을 활용하여 명확한 구조를 유지할 필요가 있다.
  - **협력 단위 최적화**: 불필요한 협력 관계를 제거하고, 과도한 협력 발생을 방지하여 성능과 유지보수성을 고려한 설계를 진행해야 한다.

<div align="center">
    <img src="https://github.com/user-attachments/assets/6d35f543-4781-4d99-968c-59f389f8b4d1" alt="Image" />
</div>

---

</br>

# 🌟 **인상 깊었던 책의 내용**

> 우리 모두를 합친 것보다 더 현명한 사람은 없다. </br> -켄 블랜차드

=> 우리 스터디 조가 최고다.

🔎 **적용 방법 고민**

- (이 내용을 어떻게 적용할 수 있을지 생각 정리)

</br>

---

</br>

# 📚 **관련 아티클 & 추가 자료**

> 📌 다른 사람이 이해하는 데 도움이 될 만한 자료 첨부  
> 📌 논문, 블로그, 영상, 실무 사례 등 공유

🔗 **추천 자료**

- 📄 [관련 논문 또는 공식 문서 링크]
- 🎥 [관련 영상 링크]
- 📝 [관련 블로그 글 링크]
